[
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "edf7aa18-42e3-4504-b331-6c9cfec43df2",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC001-User Registration and Login via Clerk",
    "description": "Validate that new users can register and existing users can log in using the Clerk authentication system with proper session management.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to the sign-up page by clicking the 'Get Started' button.\n        frame = context.pages[-1]\n        # Click the 'Get Started' button to navigate to the sign-up page\n        elem = frame.locator('xpath=html/body/main/section/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid email and password, then submit registration by clicking Continue.\n        frame = context.pages[-1]\n        # Input valid email address for registration\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input valid password for registration\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123!')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to submit registration\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Registration Complete! Welcome Aboard').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The test plan execution failed to validate user registration and login with Clerk authentication system, including session management and proper redirects.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical issue: User registration is blocked by security validation errors despite valid input. Cannot proceed with login and session management tests. Issue reported for resolution.\nBrowser Console Logs:\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36burIlAGkkMt3YKfID63A5V4OD:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36burIlAGkkMt3YKfID63A5V4OD:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765287909102077//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.804Z",
    "modified": "2025-12-09T13:45:09.227Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "c2707902-e7ed-4a55-a075-869548955559",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC002-User Authentication Failure Handling",
    "description": "Ensure the system properly handles authentication failures such as incorrect credentials or invalid session and displays appropriate error messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Scroll down to find a clickable login or sign-in link or button\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Click on the Login link to navigate to sign-in page\n        frame = context.pages[-1]\n        # Click on the Login link to navigate to sign-in page\n        elem = frame.locator('xpath=html/body/main/header/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input incorrect email address and click Continue to test error handling\n        frame = context.pages[-1]\n        # Input incorrect email address\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('wronguser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to submit incorrect email\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try accessing a protected route without logging in to verify redirection or session expiry handling\n        await page.goto('http://localhost:3000/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Sign in to').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Welcome back! Please sign in to continue').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Email address').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Password').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Continue').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Donâ€™t have an account?').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765287927284099//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.810Z",
    "modified": "2025-12-09T13:45:27.432Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "d309690b-3bfd-4694-b031-0eac6eebd980",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC003-Instagram OAuth Integration Flow",
    "description": "Validate that users can connect their Instagram account via OAuth, tokens are stored securely, and profile data is synced correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to reload the page or open a new tab to find the dashboard or integrations page\n        await page.goto('http://localhost:3000/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input email and continue sign-in process\n        frame = context.pages[-1]\n        # Input email address for sign-in\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with sign-in\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Sign up link to create a new account for testing Instagram OAuth connection\n        frame = context.pages[-1]\n        # Click on Sign up link to create a new account\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid email and password to create a new account\n        frame = context.pages[-1]\n        # Input new valid email address for sign-up\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('newtestuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input valid password for sign-up\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123!')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to submit sign-up form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Instagram connection successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Instagram OAuth connection, token storage, profile sync, or webhook setup did not complete successfully as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical blocker: sign-up process fails with security validation errors, preventing access to dashboard and Instagram integration. Cannot proceed with OAuth connection testing or token/profile verification.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/app/(website)/page.js:0:0)\n[ERROR] Warning: An error occurred during hydration. The server HTML was replaced with client content in <%s>. #document (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)\n[ERROR] The above error occurred in the <ServerRoot> component:\n\n    at ServerRoot (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:112:27)\n    at Root (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:117:11)\n\nConsider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36bur9cuKpgRDnEJu93m6nseMa7:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36bur9cuKpgRDnEJu93m6nseMa7:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36bur9cuKpgRDnEJu93m6nseMa7:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765287968185901//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.816Z",
    "modified": "2025-12-09T13:46:08.312Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "3faa4377-c148-403d-83ad-3cf53e2e4eee",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC004-Instagram OAuth Failure and Token Refresh",
    "description": "Ensure the system properly handles OAuth failures, token expiration, and refresh scenarios with relevant user feedback.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on Login to start Instagram OAuth connection process to simulate OAuth failure.\n        frame = context.pages[-1]\n        # Click on Login to initiate Instagram OAuth connection\n        elem = frame.locator('xpath=html/body/main/header/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email address and click Continue to proceed with sign-in and OAuth connection.\n        frame = context.pages[-1]\n        # Input email address for sign-in\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue to proceed with sign-in\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to navigate back or find a way to start Instagram OAuth connection to simulate OAuth failure by denying permissions.\n        frame = context.pages[-1]\n        # Click Sign up link to see if it leads to a page where Instagram OAuth connection can be initiated\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Sign in' link to return to the sign-in page and try to find a valid path to initiate Instagram OAuth connection.\n        frame = context.pages[-1]\n        # Click on 'Sign in' link to go back to sign-in page\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a valid email address and click Continue to proceed with sign-in and attempt to reach Instagram OAuth connection step.\n        frame = context.pages[-1]\n        # Input valid email address for sign-in\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue to proceed with sign-in\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=OAuth connection successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: OAuth failure, token expiration, and refresh scenarios did not pass as expected. The system did not show a success message for OAuth connection, indicating the test plan execution failed.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to sign-in blocking issue preventing OAuth failure simulation. Reported the issue for resolution. OAuth failure, token expiration, and refresh scenarios could not be tested due to this blocking error.\nBrowser Console Logs:\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36burC7tNAABzblSmTXJs1V4lix:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36burC7tNAABzblSmTXJs1V4lix:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36burC7tNAABzblSmTXJs1V4lix:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765287987508645//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.822Z",
    "modified": "2025-12-09T13:46:27.726Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "41473ebf-7035-4673-8145-cc5300ed9189",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC005-Create Comment Automation with MESSAGE Listener",
    "description": "Verify that users can create a comment trigger automation with keyword matching and MESSAGE type manual response, including post selection and activation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Login' to access user dashboard or automation creation page\n        frame = context.pages[-1]\n        # Click on Login to access user dashboard or automation creation page\n        elem = frame.locator('xpath=html/body/main/header/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email address and click Continue to proceed with login\n        frame = context.pages[-1]\n        # Input email address for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check if there is an alternative login method or sign-up option to create a valid account or try a different email\n        frame = context.pages[-1]\n        # Click on Sign up link to create a new account or find alternative login options\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid email and password, then click Continue to create account and proceed to automation creation page.\n        frame = context.pages[-1]\n        # Input valid email address for account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input valid password for account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPass123!')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to submit sign-up form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Automation Successfully Completed').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Unable to create and activate comment trigger automation with keyword matching and MESSAGE type manual response as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Stopped testing due to sign-up failure caused by security validation errors. Unable to create account and access automation creation page to complete the task of creating comment trigger automation with keyword matching and MESSAGE type manual response.\nBrowser Console Logs:\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36burH5I2MDJVqwOTyQtleu4CI8:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36burH5I2MDJVqwOTyQtleu4CI8:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36burH5I2MDJVqwOTyQtleu4CI8:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765287987280931//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.831Z",
    "modified": "2025-12-09T13:46:27.434Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "1e213819-5682-455b-ba8a-fb68b180d8c1",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC006-Create DM Automation with SMARTAI Listener",
    "description": "Validate creation of DM automations triggered by keywords with SMARTAI listener producing AI-powered responses and activation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Features' or relevant link to find automations creation page or look for a direct link to automations.\n        frame = context.pages[-1]\n        # Click on 'Features' link to navigate towards automations creation or related page\n        elem = frame.locator('xpath=html/body/main/header/div/nav/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking 'Login' to access user dashboard where automation creation might be available.\n        frame = context.pages[-1]\n        # Click on 'Login' to access user dashboard or account area\n        elem = frame.locator('xpath=html/body/main/header/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email address and click Continue to sign in.\n        frame = context.pages[-1]\n        # Input email address for sign-in\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with sign-in\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Sign up' link to start account creation process.\n        frame = context.pages[-1]\n        # Click on 'Sign up' link to create a new account\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid email and password, then click Continue to create account.\n        frame = context.pages[-1]\n        # Input new email address for account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('automationtester@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('StrongPassword123!')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to submit sign-up form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Automation Successfully Created and Activated').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The DM automation triggered by keywords with SMARTAI listener was not created or activated successfully as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to create a valid user account. Sign-up process blocked by security validation errors. Cannot proceed to automation creation and validation steps without valid authentication. Please resolve account creation issues or provide valid test credentials.\nBrowser Console Logs:\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36bus1FvKe7sw6qZ7axtb4SHcKB:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36bus1FvKe7sw6qZ7axtb4SHcKB:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36bus1FvKe7sw6qZ7axtb4SHcKB:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765288020505492//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.837Z",
    "modified": "2025-12-09T13:47:00.692Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "f9f5f186-3dd3-4c18-86e7-03f83c6cd002",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC007-Webhook Event Handling for Comments and DMs",
    "description": "Ensure incoming Instagram webhook events for comments and DMs are validated, matched against active automations, and responses are executed correctly with metrics updated.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to login page to access webhook testing or automation management interface\n        frame = context.pages[-1]\n        # Click on Login to access user dashboard for webhook and automation testing\n        elem = frame.locator('xpath=html/body/main/header/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email address and click Continue to login\n        frame = context.pages[-1]\n        # Input email address for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Sign up link to create a new account or find alternative login method\n        frame = context.pages[-1]\n        # Click on Sign up link to create a new account or find alternative login method\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid email and password, then click Continue to create account\n        frame = context.pages[-1]\n        # Input valid email address for new account\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input valid password for new account\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('ValidPass123!')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to submit sign-up form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Instagram webhook event processed successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Incoming Instagram webhook events for comments and DMs were not validated, matched, or responded to correctly, or metrics were not updated as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Stopped further actions due to sign-up validation failure blocking account creation. Reported issue for resolution. Unable to proceed with webhook event validation and automation response testing without account access.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/main-app.js?v=1765287788764:0:0)\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36burEFv29QBYY31AEeIPZSoRkW:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36burEFv29QBYY31AEeIPZSoRkW:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36burEFv29QBYY31AEeIPZSoRkW:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765287974809739//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.842Z",
    "modified": "2025-12-09T13:46:14.936Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "d4a42c88-fcb6-4a7c-aa27-5c96fdaf017d",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC008-Dashboard Metrics and Automation Status Display",
    "description": "Verify dashboard UI correctly displays overview metrics, active/inactive automation statuses, and updates these in near-real-time after events.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the Login link to proceed to login page.\n        frame = context.pages[-1]\n        # Click on the Login link to go to login page\n        elem = frame.locator('xpath=html/body/main/header/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email address and click Continue to proceed with login.\n        frame = context.pages[-1]\n        # Input email address for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a different valid email address and try to login again.\n        frame = context.pages[-1]\n        # Input a different valid email address for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to attempt login with new email\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check if there is an alternative login method or sign up a new user to proceed.\n        frame = context.pages[-1]\n        # Click on Sign up link to create a new account if login fails\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email and password to create a new account and proceed.\n        frame = context.pages[-1]\n        # Input email address for new account\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('newuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for new account\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('StrongPassword123!')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to submit sign-up form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try refreshing the page to clear any potential issues and attempt sign-up again or consider reaching out to support if issue persists.\n        frame = context.pages[-1]\n        # Click Continue button again to retry sign-up after refreshing or correcting inputs\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Refresh the page to clear potential issues and try sign-up again or consider clicking 'Sign in' to attempt login again.\n        frame = context.pages[-1]\n        # Click 'Sign in' link to return to login page and try alternative login attempt\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid email and password to attempt login and access dashboard.\n        frame = context.pages[-1]\n        # Input valid email address for user with connected Instagram and active automations\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@connectedinsta.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dashboard Overview Metrics Updated Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Dashboard UI did not correctly display overview metrics, active/inactive automation statuses, or update these in near-real-time after events as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Reported the login issue preventing access to the dashboard. Cannot proceed with verifying dashboard UI and real-time updates without successful login. Task stopped due to authentication blockage.\nBrowser Console Logs:\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36burnvRPiyxFb6TT7SRCKeGZM9:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36burnvRPiyxFb6TT7SRCKeGZM9:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36burnvRPiyxFb6TT7SRCKeGZM9:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36burnvRPiyxFb6TT7SRCKeGZM9:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36burnvRPiyxFb6TT7SRCKeGZM9:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36burnvRPiyxFb6TT7SRCKeGZM9:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765288061828878//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.848Z",
    "modified": "2025-12-09T13:47:42.080Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "99a1db87-7a0d-47ea-a437-bed8ee69c721",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC009-Subscription Plan Upgrade via Stripe Checkout",
    "description": "Validate that users can successfully upgrade from Free to Pro plan through Stripe checkout and gain access to SMARTAI features.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to account settings or payment page to start upgrade process.\n        frame = context.pages[-1]\n        # Click Login to access user account for upgrade\n        elem = frame.locator('xpath=html/body/main/header/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email address and click Continue to login.\n        frame = context.pages[-1]\n        # Input email address for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to sign up or find alternative login method to access account settings or payment page.\n        frame = context.pages[-1]\n        # Click Sign up link to create a new account for testing upgrade process\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a valid email and password, then click Continue to create the account.\n        frame = context.pages[-1]\n        # Input email address for new account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser+proupgrade@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for new account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('StrongPassword123!')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to submit sign-up form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to refresh the sign-up page to clear validation errors and attempt account creation again or consider alternative approach to access account settings or payment page.\n        frame = context.pages[-1]\n        # Click Continue button again to retry sign-up after refreshing or clearing errors\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Input a different email address for new account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser+proupgrade2@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for new account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/form/div/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('StrongPassword123!')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to submit sign-up form again\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Upgrade to Platinum Plan').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The upgrade from Free to Pro plan through Stripe checkout did not complete successfully, or access to SMARTAI features was not granted as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing cannot proceed because account creation is blocked by persistent security validation errors on the sign-up page. This prevents access to account settings and payment page needed to test the upgrade from Free to Pro plan through Stripe checkout and access to SMARTAI features. Please fix the sign-up validation issue to enable further testing.\nBrowser Console Logs:\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36buryPCr1Xm07rFNDunz5I7IQe:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36buryPCr1Xm07rFNDunz5I7IQe:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36buryPCr1Xm07rFNDunz5I7IQe:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36buryPCr1Xm07rFNDunz5I7IQe:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36buryPCr1Xm07rFNDunz5I7IQe:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765288025899617//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.855Z",
    "modified": "2025-12-09T13:47:06.036Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "ba17925b-0ae1-4764-9d0a-07fc630725f3",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC010-Subscription Upgrade Failure Handling",
    "description": "Ensure payment failures during subscription upgrades are handled gracefully with informative user messages and no feature access granted.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on Login to access user account for plan upgrade.\n        frame = context.pages[-1]\n        # Click on Login to access user account for plan upgrade\n        elem = frame.locator('xpath=html/body/main/header/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid email address and click Continue to proceed with login.\n        frame = context.pages[-1]\n        # Input email address for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Upgrade Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Payment failure during subscription upgrade was not handled gracefully. Expected payment failure message was not shown, and subscription upgrade may have been incorrectly granted.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to login failure with 'Identifier is invalid.' error. Cannot proceed with subscription upgrade and payment failure handling tests. Issue reported.\nBrowser Console Logs:\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36burlD0h8ojvU2CPSylkAspz7u:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36burlD0h8ojvU2CPSylkAspz7u:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765287908938373//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.862Z",
    "modified": "2025-12-09T13:45:09.068Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "b184a39f-5b9d-4595-8585-c27c3c1381d5",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC011-Data Fetching and Caching Efficiency",
    "description": "Validate React Query hooks effectively cache data for user, automations, and integrations, minimizing redundant API calls and ensuring responsive UI.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to the dashboard page to start testing caching and network calls.\n        frame = context.pages[-1]\n        # Click on 'Features' link to navigate to dashboard or relevant page for testing React Query hooks caching.\n        elem = frame.locator('xpath=html/body/main/header/div/nav/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to find and click on a different navigation element or link that leads to the dashboard or automations page for testing React Query caching.\n        frame = context.pages[-1]\n        # Click on 'Login' link to see if it leads to dashboard or user area for testing caching.\n        elem = frame.locator('xpath=html/body/main/header/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email address to sign in and proceed to dashboard.\n        frame = context.pages[-1]\n        # Input email address for sign-in.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with sign-in.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Data caching is flawless and network calls are zero').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: React Query hooks did not effectively cache data, resulting in redundant API calls and potential slow UI responsiveness as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing cannot proceed because the sign-in process is blocked by an invalid identifier error. Access to dashboard and automations pages is required to validate React Query hooks caching and network call minimization. Please provide valid credentials or fix the sign-in issue to continue testing.\nBrowser Console Logs:\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36busOKEC9Qs9KH0qJPclPhT6jW:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36busOKEC9Qs9KH0qJPclPhT6jW:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765287975980048//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.868Z",
    "modified": "2025-12-09T13:46:16.117Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "b8f95ce6-11b5-4635-9a1b-277cb9112c84",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC012-Dark/Light Theme Toggle",
    "description": "Check that the dark and light mode toggle switches UI theme correctly across pages and persists user preference.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on Login to access a protected UI page (dashboard) for theme toggle testing.\n        frame = context.pages[-1]\n        # Click on Login to navigate to the login page or dashboard.\n        elem = frame.locator('xpath=html/body/main/header/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email address and click Continue to sign in and access the dashboard.\n        frame = context.pages[-1]\n        # Input email address for sign-in.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with sign-in.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Theme toggle failed to switch modes').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The dark and light mode toggle did not switch UI themes correctly or persist user preference as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to sign-in failure preventing access to protected pages for theme toggle testing. Reported the issue for resolution.\nBrowser Console Logs:\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36busf3fk7WxLk9KDPs29UTNJf5:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36busf3fk7WxLk9KDPs29UTNJf5:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765287922908849//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.874Z",
    "modified": "2025-12-09T13:45:23.079Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "dbe5daab-2e72-4780-98bd-65015991c134",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC013-Rich Media Support in Automated Responses",
    "description": "Ensure that manual and SMARTAI automated responses can include rich media such as images, links, and formatted text displayed correctly on Instagram.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to login or automation creation page to create or edit an automation with MESSAGE listener including rich media.\n        frame = context.pages[-1]\n        # Click on Login to access automation creation or editing features\n        elem = frame.locator('xpath=html/body/main/footer/div/div[2]/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Rich Media Automation Success').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The automated response on Instagram does not contain all rich media elements correctly as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Reported navigation issue on the homepage preventing access to automation creation or editing features. Stopping further actions as the task cannot proceed without access.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/css/app/layout.css?v=1765287795269:0:0)\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[WARNING] Image with src \"/mation-image.jpg\" has \"fill\" and parent element with invalid \"position\". Provided \"static\" should be one of absolute,fixed,relative. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js:15:20)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36bus7vUU0ZQOKplORjYVqA3bVG:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765287902974195//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.880Z",
    "modified": "2025-12-09T13:45:03.124Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "96e4a07b-398a-458e-a6a2-5286d8faf03f",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC014-Error Handling and User Notifications",
    "description": "Test global error logger captures errors and verify users receive clear, user-friendly error messages during failures in various flows.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on Login to access user dashboard or automation creation to trigger errors.\n        frame = context.pages[-1]\n        # Click on Login to proceed to user dashboard or automation creation page\n        elem = frame.locator('xpath=html/body/main/header/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input invalid email and submit to trigger validation error.\n        frame = context.pages[-1]\n        # Input invalid email to trigger validation error\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-email')\n        \n\n        frame = context.pages[-1]\n        # Click Continue to submit invalid email and trigger validation error\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate network failure during Instagram OAuth or API fetch to test error logging and user message.\n        await page.goto('http://localhost:3000/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input valid email to proceed with login.\n        frame = context.pages[-1]\n        # Input valid email to proceed with login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue to submit valid email and proceed\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Unexpected Automation Success Message').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test plan failed: Global error logger did not capture errors properly, and user-friendly error messages were not displayed during failures in automation creation, network failure, or backend errors.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to login failure blocking access to further test scenarios. Reported the issue for resolution.\nBrowser Console Logs:\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36busCcHXEiF9afyAUbDrDcSab9:0:0)\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36busCcHXEiF9afyAUbDrDcSab9:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36busCcHXEiF9afyAUbDrDcSab9:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765287971770981//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.886Z",
    "modified": "2025-12-09T13:46:11.902Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "6634f0f6-b0cc-45ba-b350-983610461317",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC015-Loading State UI Components",
    "description": "Validate skeleton loaders and loading indicators appear appropriately during data fetching or slow operations without blocking user interaction unexpectedly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to automations page with artificial network delay to test skeleton loader visibility.\n        frame = context.pages[-1]\n        # Click on 'Features' link to navigate to automations page or relevant section.\n        elem = frame.locator('xpath=html/body/main/header/div/nav/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Find and click the link or button to navigate to the automations page with artificial network delay.\n        await page.mouse.wheel(0, 300)\n        \n\n        frame = context.pages[-1]\n        # Click on 'Get Started' button to navigate to automations page or relevant section for testing.\n        elem = frame.locator('xpath=html/body/main/section/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email and password, then click Continue to proceed.\n        frame = context.pages[-1]\n        # Input email address for sign-up.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for sign-up.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to submit sign-up form and proceed.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Sign in' link to attempt login with existing account to proceed to automations page.\n        frame = context.pages[-1]\n        # Click on 'Sign in' link to navigate to login page.\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check if password input is present or if sign-in proceeds with email only, then click Continue.\n        frame = context.pages[-1]\n        # Click Continue button to attempt sign-in with email only or proceed to next step.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to clear the email input and enter a different valid email, then click Continue to test if sign-in can proceed.\n        frame = context.pages[-1]\n        # Clear the email input field to try a different email.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        # -> Input a valid email address in the email input field and click Continue to attempt sign-in.\n        frame = context.pages[-1]\n        # Input a valid email address to attempt sign-in.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to submit the email and proceed with sign-in.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Automation Load Complete').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Skeleton loaders and loading indicators did not appear appropriately during data fetching or slow operations as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing of skeleton loaders and loading indicators could not proceed because sign-in is blocked by persistent 'Identifier is invalid.' error. Unable to reach automations page to validate skeleton loaders during data fetching or slow operations. Please provide valid test credentials or fix sign-in issue to continue testing.\nBrowser Console Logs:\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36bus8YNAF0Kkqaug6RRqQqlA6H:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36bus8YNAF0Kkqaug6RRqQqlA6H:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36bus8YNAF0Kkqaug6RRqQqlA6H:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36bus8YNAF0Kkqaug6RRqQqlA6H:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765288040245194//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.893Z",
    "modified": "2025-12-09T13:47:20.405Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "4aca3d90-da1d-4ae2-9fc4-bc7558810931",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC016-End-to-End New User Onboarding Flow",
    "description": "Verify a new user can register, connect Instagram, and create a first automation with guided prompts and that all steps complete without errors.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to navigate to a known sign-up or login URL or open a new tab to search for registration page.\n        await page.goto('http://localhost:3000/sign-up', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to reload the page or check for any hidden elements or errors on the page.\n        await page.goto('http://localhost:3000/sign-up', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Fill in the email and password fields with valid test credentials and click Continue to submit the form.\n        frame = context.pages[-1]\n        # Input test email address\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input test password\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123!')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to submit registration form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Registration Complete! Welcome to Your Dashboard').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The user registration, Instagram connection, or automation creation did not complete successfully as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to critical sign-up failure caused by security validation errors. User registration cannot proceed, blocking the entire onboarding and automation creation flow. Please investigate and fix the sign-up validation issue.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:3000/_next/static/chunks/app-pages-internals.js:0:0)\n[ERROR] Warning: An error occurred during hydration. The server HTML was replaced with client content in <%s>. #document (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)\n[ERROR] The above error occurred in the <ServerRoot> component:\n\n    at ServerRoot (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:112:27)\n    at Root (webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:117:11)\n\nConsider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries. (at webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/app-index.js:32:21)\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36bus6JXOY6Goov7gdbuLztF63U:0:0)\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36bus6JXOY6Goov7gdbuLztF63U:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36bus6JXOY6Goov7gdbuLztF63U:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/176528795368578//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.899Z",
    "modified": "2025-12-09T13:45:53.825Z"
  },
  {
    "projectId": "69ed9613-2d44-4fca-999b-7e624da27493",
    "testId": "0fe0a8ab-1fa4-42fe-9fbb-ec96aca2f3f1",
    "userId": "74e834b8-4061-70f2-317e-ada51207a37c",
    "title": "TC017-Automation Activation and Deactivation Flow",
    "description": "Verify users can activate and deactivate automations from the dashboard and changes reflect immediately in UI and automation behavior.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on 'Login' to access user dashboard for automation management.\n        frame = context.pages[-1]\n        # Click on Login to access user dashboard\n        elem = frame.locator('xpath=html/body/main/header/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email address and click Continue to proceed with login.\n        frame = context.pages[-1]\n        # Input email address for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Clear the email input and try a different valid email or check for alternative login options.\n        frame = context.pages[-1]\n        # Clear the invalid email input\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Input a valid email address for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue button to proceed with login\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check if password input can be used or if alternative login options exist to proceed.\n        frame = context.pages[-1]\n        # Clear the email input to try alternative login approach\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Re-enter email to check if password input can be used\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('validuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Click Continue to see if password input appears or alternative login options\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Check if the 'Sign up' link or other elements provide alternative ways to access or create an account for testing.\n        frame = context.pages[-1]\n        # Click on 'Sign up' link to check for alternative account creation or login options\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid email and password to create a new account and proceed.\n        frame = context.pages[-1]\n        # Input email address for new account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('newtestuser@example.com')\n        \n\n        frame = context.pages[-1]\n        # Input password for new account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div/div[2]/div/div/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123!')\n        \n\n        frame = context.pages[-1]\n        # Click Continue to submit new account creation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Refresh the sign-up page to clear validation errors and try again or consider reaching out to support as suggested.\n        frame = context.pages[-1]\n        # Click Continue again to retry sign-up\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Continue again to retry sign-up\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[3]/form/div[2]/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Automation Activated Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution has failed because the automation activation and deactivation functionality did not work as expected. The automation status did not change immediately in the UI or the automation behavior did not reflect the changes.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Testing stopped due to inability to login or create an account. Persistent errors prevent access to dashboard and automation listing, blocking the verification of automation activation and deactivation. Issue reported for resolution.\nBrowser Console Logs:\n[WARNING] Clerk: Clerk has been loaded with development keys. Development instances have strict usage limits and should not be used when deploying your application to production. Learn more: https://clerk.com/docs/deployments/overview (at https://innocent-seagull-15.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js:18:6881)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/environment?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&_method=PATCH&__clerk_db_jwt=dvb_36busNrxPbGoOXWKkedDmTeaSz5:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36busNrxPbGoOXWKkedDmTeaSz5:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36busNrxPbGoOXWKkedDmTeaSz5:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 422 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ins?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36busNrxPbGoOXWKkedDmTeaSz5:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36busNrxPbGoOXWKkedDmTeaSz5:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36busNrxPbGoOXWKkedDmTeaSz5:0:0)\n[ERROR] Failed to load resource: the server responded with a status of 400 () (at https://innocent-seagull-15.clerk.accounts.dev/v1/client/sign_ups?__clerk_api_version=2025-11-10&_clerk_js_version=5.112.1&__clerk_db_jwt=dvb_36busNrxPbGoOXWKkedDmTeaSz5:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/74e834b8-4061-70f2-317e-ada51207a37c/1765288079670012//tmp/test_task/result.webm",
    "created": "2025-12-09T13:42:59.905Z",
    "modified": "2025-12-09T13:47:59.857Z"
  }
]
